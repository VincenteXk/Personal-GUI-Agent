# 三阶段关系提取策略

## 概述

为了更准确、完整地表达复杂事件中的多方关系，我们采用**三阶段关系提取策略**：

1. **Phase 1: 提取原子关系** - 所有单一直接动作
2. **Phase 2: 识别复杂事件** - 涉及多方的复杂事件
3. **Phase 3: 另起复杂关系** - 为复杂事件额外创建关系（使用 refer）

**核心原则**: 原子关系和复杂关系**共存**，而非替换！

---

## Phase 1: 提取所有原子关系

### 定义

**原子关系** = 单一、直接的动作或连接，描述两个节点之间的最基本关系。

### 必须提取的原子关系类型

1. **用户操作**:
   - `我 -> 实体:类`
   - 示例: 我打开、我看到、我联系、我购买

2. **内容传递**:
   - `内容:类 -> 目标:类`
   - 示例: 视频分享给某人、商品发送给某人

3. **平台关系**:
   - `平台:类 -> 实体:类`
   - 示例: 平台展示内容、平台连接用户

4. **发现三角**:
   - `我 -> 平台:类`, `我 -> 内容:类`, `平台:类 -> 内容:类`
   - 示例: 我在抖音上发现了张三的店

### 原子关系的特征

- ✅ **refer 字段**: 必须是 `NONE`（或空数组 `[]`）
- ✅ **描述简单**: 描述单一动作，不涉及多方参与
- ✅ **尽可能多**: 每个单一动作都应有原子关系
- ✅ **使用 entity:class**: 优先使用功能性类节点

### 示例

**文本**: "我在小红书上看到一个关于AI绘图的视频，然后用微信分享给了小明"

**Phase 1 原子关系**:

```
1. ("relationship"|我|小红书:可启动应用|我打开小红书|1|NONE)
2. ("relationship"|我|小红书:内容平台|我在小红书上浏览内容|1|NONE)
3. ("relationship"|我|一个关于AI绘图的视频:内容|我看到了这个视频|1|NONE)
4. ("relationship"|小红书:内容平台|一个关于AI绘图的视频:内容|小红书展示了这个视频|1|NONE)
5. ("relationship"|我|微信:可启动应用|我打开微信|1|NONE)
6. ("relationship"|我|小明:可联系人|我联系了小明|1|NONE)
7. ("relationship"|一个关于AI绘图的视频:内容|小明:可联系人|我把视频分享给小明|1|NONE)
8. ("relationship"|微信:交流平台|小明:可联系人|我在微信上联系小明|1|NONE)
```

**分析**:

- 关系1: 我打开小红书（用户操作）
- 关系2,3,4: 发现三角（我在小红书上发现视频）
- 关系5: 我打开微信（用户操作）
- 关系6: 我联系小明（用户操作）
- 关系7: 视频分享给小明（内容传递）
- 关系8: 微信连接小明（平台关系）

---

## Phase 2: 识别复杂事件

### 定义

**复杂事件** = 涉及 >2 个实体的事件，仅靠原子关系无法完整表达。

### 判断标准

1. **多方参与**: 事件涉及 3 个或更多实体
2. **语义完整性**: 需要同时表达主体、客体、工具/媒介、内容等
3. **表达需求**: "WHO did WHAT to WHOM through WHERE/WHAT"

### 复杂事件示例

| 文本 | 参与实体 | 是否复杂事件 |
|------|----------|--------------|
| "我打开微信" | 我, 微信 | ❌ 否（2方） |
| "我联系小明" | 我, 小明 | ❌ 否（2方） |
| "我通过微信把视频分享给小明" | 我, 微信, 视频, 小明 | ✅ 是（4方） |
| "我在美团上用支付宝订了张三的店的咖啡" | 我, 美团, 支付宝, 张三的店, 咖啡 | ✅ 是（5方） |

### 识别步骤

1. **列出参与实体**: 数一数事件中涉及多少个实体
2. **检查表达完整性**: 原子关系能否完整表达？
3. **判断**: 如果 >2 个实体且原子关系表达不完整，则是复杂事件

---

## Phase 3: 另起复杂关系

### 核心原则

**重要**: 这是**额外增加**的关系，不是替换原子关系！

### 另起关系的规则

1. **选择核心连接**:
   - 选择事件中最核心的两个参与者作为 source 和 target
   - 通常是"工具/平台"或"内容"与"目标"

2. **补充 refer**:
   - 将其他参与实体（除了 source 和 target）放入 refer 字段
   - 格式: `entity1:class1,entity2:class2` (逗号分隔，无空格)

3. **描述完整语义**:
   - 关系描述应该反映完整的复杂事件
   - 不是简单动作，而是完整的"通过...做..."

4. **"我"不需要在 refer 中**:
   - "我"总是隐含存在于用户的事件中
   - 其他实体需要明确标注

### 另起关系的模式

#### 模式 A: 工具/平台 -> 目标

```
source: 工具/平台:类
target: 目标:类
refer: [内容:类]
description: 通过[工具]将[内容]发送给[目标]
```

**示例**:

```
("relationship"|微信:交流平台|小明:可联系人|我通过微信把视频分享给小明|1|一个关于AI绘图的视频:内容)
```

#### 模式 B: 内容 -> 目标

```
source: 内容:类
target: 目标:类
refer: [工具/平台:类]
description: 在[工具]上将[内容]分享给[目标]
```

**示例**:

```
("relationship"|一个关于AI绘图的视频:内容|小明:可联系人|我在微信上把视频分享给小明|1|微信:交流平台)
```

### 为什么需要两条复杂关系？

不同的视角提供不同的查询能力：

- **模式 A** (工具 -> 目标): 回答"我通过微信做了什么？"
- **模式 B** (内容 -> 目标): 回答"这个视频被分享给了谁？"

两条关系都存在，可以支持更丰富的查询。

---

## 完整示例

### 示例 1: 分享视频

**文本**: "我通过微信把一个关于AI绘图的视频分享给小明"

#### Phase 1: 原子关系

```
1. ("relationship"|我|微信:可启动应用|我打开微信|1|NONE)
2. ("relationship"|我|小明:可联系人|我联系了小明|1|NONE)
3. ("relationship"|一个关于AI绘图的视频:内容|小明:可联系人|我把视频分享给小明|1|NONE)
4. ("relationship"|微信:交流平台|小明:可联系人|我在微信上联系小明|1|NONE)
```

#### Phase 2: 识别复杂事件

- 参与实体: 我, 微信, 视频, 小明 (4方)
- 判断: 是复杂事件

#### Phase 3: 另起复杂关系

```
5. ("relationship"|微信:交流平台|小明:可联系人|我通过微信把视频分享给小明|1|一个关于AI绘图的视频:内容)
6. ("relationship"|一个关于AI绘图的视频:内容|小明:可联系人|我在微信上把视频分享给小明|1|微信:交流平台)
```

**总计**: 6 条关系（4 条原子 + 2 条复杂）

---

### 示例 2: 购物场景

**文本**: "我在美团上用支付宝订了张三的店的咖啡"

#### Phase 1: 原子关系

```
1. ("relationship"|我|美团:可启动应用|我打开美团|1|NONE)
2. ("relationship"|我|美团:购物平台|我在美团上浏览|1|NONE)
3. ("relationship"|我|张三的店:餐厅|我订购了张三的店的商品|1|NONE)
4. ("relationship"|我|支付宝:支付工具|我使用支付宝支付|1|NONE)
5. ("relationship"|美团:购物平台|张三的店:餐厅|美团展示张三的店|1|NONE)
6. ("relationship"|我|咖啡:商品|我订购了咖啡|1|NONE)
```

#### Phase 2: 识别复杂事件

- 参与实体: 我, 美团, 支付宝, 张三的店, 咖啡 (5方)
- 判断: 是复杂事件

#### Phase 3: 另起复杂关系

```
7. ("relationship"|美团:购物平台|张三的店:餐厅|我在美团上订购张三的店的咖啡|1|咖啡:商品,支付宝:支付工具)
8. ("relationship"|咖啡:商品|张三的店:餐厅|我通过美团用支付宝订购咖啡|1|美团:购物平台,支付宝:支付工具)
```

**总计**: 8 条关系（6 条原子 + 2 条复杂）

---

### 示例 3: 发现场景（只有原子关系）

**文本**: "我在抖音上刷到张三的店"

#### Phase 1: 原子关系（发现三角）

```
1. ("relationship"|我|抖音:可启动应用|我打开抖音|1|NONE)
2. ("relationship"|我|抖音:内容平台|我在抖音上浏览内容|1|NONE)
3. ("relationship"|我|张三的店:餐厅|我发现了张三的店|1|NONE)
4. ("relationship"|抖音:内容平台|张三的店:餐厅|张三的店在抖音上被展示|1|NONE)
```

#### Phase 2: 识别复杂事件

- 参与实体: 我, 抖音, 张三的店 (3方)
- 判断: 虽然有3方，但"发现"是一个标准模式（发现三角），原子关系已经完整表达

#### Phase 3: 不需要另起关系

此例只有原子关系，无复杂事件关系。

**总计**: 4 条关系（4 条原子 + 0 条复杂）

---

## 关系唯一性判断

### 判断标准

关系被认为是**同一个**当且仅当：

1. `source` 相同
2. `target` 相同
3. `description` 相同（或语义相同）
4. **`refer` 相同**（内容完全一致，顺序无关）

### 合并规则

#### ✅ 可以合并（累加 count）

```
关系1: 我 -> 某应用:可启动应用, description="打开应用", refer=[], count=1
关系2: 我 -> 某应用:可启动应用, description="打开应用", refer=[], count=1
→ 合并为: count=2
```

#### ❌ 不能合并（保持独立）

```
关系1: 我 -> 小明:可联系人, description="联系小明", refer=["问作业"], count=1
关系2: 我 -> 小明:可联系人, description="联系小明", refer=["微信:交流平台","分享视频"], count=1
→ 保持为两条独立关系（refer 不同，目的不同）
```

#### ✅ 可以合并（refer 顺序不影响）

```
关系1: 微信:交流平台 -> 小明:可联系人, refer=["视频:内容","小程序:工具"]
关系2: 微信:交流平台 -> 小明:可联系人, refer=["小程序:工具","视频:内容"]
→ 可以合并（内容相同，只是顺序不同）
```

---

## 实现细节

### 提取阶段 (`extract_graph.txt`)

1. **分阶段思考**:
   - 先列出所有原子关系
   - 再识别复杂事件
   - 最后为复杂事件另起关系

2. **注释标记**:

   ```
   # Phase 1: 原子关系
   ...
   # Phase 3: 复杂事件关系
   ...
   ```

3. **Refer 格式**:
   - 原子关系: `NONE`
   - 复杂关系: `entity1:class1,entity2:class2`

### 检查阶段 (`check_extraction.txt`)

1. **检查原子关系完整性**:
   - 每个单一动作是否都有原子关系？
   - 原子关系的 refer 是否都是 NONE？

2. **检查复杂关系**:
   - 复杂事件是否另起了关系？
   - refer 字段是否正确？
   - "我" 是否错误地出现在 refer 中？

3. **共存检查**:
   - 原子关系和复杂关系是否共存？
   - 是否错误地用复杂关系替换了原子关系？

### 合并阶段 (`smart_merge.txt`)

1. **理解两种关系**:
   - 原子关系: refer=[]
   - 复杂关系: refer=[其他实体]

2. **不要错误合并**:
   - 原子关系和复杂关系不应合并
   - 即使 source 和 target 相同，refer 不同就是不同关系

3. **Refer 比较**:
   - 比较 refer 数组内容（顺序无关）
   - 内容完全一致才能合并

---

## 优势

### 1. 完整性

- **原子关系**: 保留所有基本动作，不丢失任何信息
- **复杂关系**: 表达完整的多方事件语义

### 2. 查询能力

支持更丰富的查询：

- "我通过微信做了什么？" → 查询 source=微信 的复杂关系
- "我联系过小明几次？" → 查询 target=小明 的原子关系（count累加）
- "哪些内容被分享给了小明？" → 查询 target=小明, refer 包含内容的关系

### 3. 清晰度

- **原子关系**: 简单直接，易于理解
- **复杂关系**: 明确标注参与方，语义清晰

### 4. 灵活性

- 可以单独查询原子关系（基础图谱）
- 可以单独查询复杂关系（完整事件）
- 可以组合查询（全面分析）

---

## 注意事项

### 1. 不要替换

❌ **错误**: 只提取复杂关系，删除原子关系
✅ **正确**: 原子关系和复杂关系都提取，共存

### 2. Refer 不包含 "我"

❌ **错误**: `refer=["我", "微信:交流平台"]`
✅ **正确**: `refer=["微信:交流平台"]`

原因: "我" 总是隐含存在于用户的事件中

### 3. 使用 Entity:Class

❌ **错误**: `("relationship"|我|微信|我打开微信|1|NONE)`
✅ **正确**: `("relationship"|我|微信:可启动应用|我打开微信|1|NONE)`

原因: 明确标识功能性关系

### 4. Refer 格式

❌ **错误**: `refer=["视频", "微信"]` (无类标识)
✅ **正确**: `refer=["视频:内容", "微信:交流平台"]`

❌ **错误**: `refer=["视频:内容, 微信:交流平台"]` (一个字符串)
✅ **正确**: `refer=["视频:内容","微信:交流平台"]` (数组)

---

## 测试用例

### 测试 1: 分享视频

**输入**: "我通过微信把一个关于AI绘图的视频分享给小明"

**预期**:

- 实体: 我, 微信, 小明, 关于AI绘图的视频
- 原子关系: 4条（打开微信、联系小明、分享视频、微信联系）
- 复杂关系: 2条（微信->小明, 视频->小明，带refer）
- 总计: 6条关系

### 测试 2: 购物

**输入**: "我在美团上用支付宝订了张三的店的咖啡"

**预期**:

- 实体: 我, 美团, 支付宝, 张三的店, 咖啡
- 原子关系: 6条
- 复杂关系: 2条（带refer）
- 总计: 8条关系

### 测试 3: 发现

**输入**: "我在抖音上刷到张三的店"

**预期**:

- 实体: 我, 抖音, 张三的店
- 原子关系: 4条（发现三角 + 打开抖音）
- 复杂关系: 0条（发现是标准模式，无需复杂关系）
- 总计: 4条关系

---

## 总结

三阶段关系提取策略通过**原子关系**和**复杂关系**的结合，实现了：

1. ✅ **完整性**: 不丢失任何基本动作信息
2. ✅ **语义性**: 完整表达多方参与的复杂事件
3. ✅ **查询性**: 支持丰富的图谱查询能力
4. ✅ **清晰性**: 原子/复杂关系职责分明

**核心原则**: 原子关系和复杂关系**共存**，提供不同层次的语义表达！
