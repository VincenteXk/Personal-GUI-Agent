# 提示词优化：三阶段关系提取策略

## 更新概述

本次优化引入了**三阶段关系提取策略**，以更准确、完整地表达复杂事件中的多方关系。

**核心改进**:

- Phase 1: 提取所有原子关系（单一动作，refer=NONE）
- Phase 2: 识别复杂事件（多方参与）
- Phase 3: 为复杂事件另起关系（使用 refer 字段）

**关键原则**: 原子关系和复杂关系**共存**，而非替换！

---

## 修改文件

### 1. `config/prompts/extract_graph.txt`

#### 主要修改

**STEP 3 重写**: 从简单的关系提取改为三阶段策略

**新增内容**:

```markdown
**三阶段关系提取策略 (Three-Phase Strategy)**:

### Phase 1: 提取所有原子关系 (Extract ALL Atomic Relationships)
- 原子关系 = 单一、直接的动作，refer=NONE
- 必须提取: 用户操作、内容传递、平台关系、发现三角
- 尽可能多地提取，每个单一动作都应有原子关系

### Phase 2: 识别复杂事件 (Identify Complex Events)
- 复杂事件 = 涉及 >2 个实体的事件
- 判断标准: "WHO did WHAT to WHOM through WHERE/WHAT"

### Phase 3: 为复杂事件另起关系 (Create Separate Relationships)
- 这是额外增加的关系，不是替换原子关系
- 选择核心连接作为 source/target
- 补充 refer 字段
- "我" 不需要在 refer 中
```

**完整示例**: "我在小红书上看到一个关于AI绘图的视频，然后用微信分享给了小明"

Phase 1 原子关系 (8条):

1. 我 -> 小红书:可启动应用 (打开)
2. 我 -> 小红书:内容平台 (浏览)
3. 我 -> 视频:内容 (看到)
4. 小红书:内容平台 -> 视频:内容 (展示)
5. 我 -> 微信:可启动应用 (打开)
6. 我 -> 小明:可联系人 (联系)
7. 视频:内容 -> 小明:可联系人 (分享)
8. 微信:交流平台 -> 小明:可联系人 (联系)

Phase 3 复杂关系 (2条):
9. 微信:交流平台 -> 小明:可联系人, refer=[视频:内容]
10. 视频:内容 -> 小明:可联系人, refer=[微信:交流平台]

**CRITICAL RULES 更新**:

```markdown
**RULE 1 - 原子关系优先，复合关系另起**:
- 先提取所有原子关系（refer=NONE）
- 再为复杂事件另起关系（使用 refer）
- 两者共存，不是替换关系

**RULE 5 - "我" 不在 refer 中**:
- "我" 作为用户本人总是隐含存在于事件中
- 其他实体在 refer 中标注即可
```

**Example 1 更新**: 完整展示三阶段策略

```
STEP 3 - Relationships:
# Phase 1: 原子关系（所有基本动作）
("relationship"|我|微信:可启动应用|我打开微信|1|NONE)
("relationship"|我|小明:可联系人|我联系了小明|1|NONE)
("relationship"|关于AI绘图的视频:内容|小明:可联系人|我把视频分享给小明|1|NONE)
("relationship"|微信:交流平台|小明:可联系人|我在微信上联系小明|1|NONE)
# Phase 3: 复杂事件的另起关系（使用 refer）
("relationship"|微信:交流平台|小明:可联系人|我通过微信把视频分享给小明|1|关于AI绘图的视频:内容)
("relationship"|关于AI绘图的视频:内容|小明:可联系人|我在微信上把视频分享给小明|1|微信:交流平台)
```

**Example 2 更新**: 发现三角，添加"打开"动作

```
STEP 3 - Relationships:
# Phase 1: 原子关系（发现三角）
("relationship"|我|抖音:可启动应用|我打开抖音|1|NONE)
("relationship"|我|抖音:内容平台|我在抖音上浏览内容|1|NONE)
("relationship"|我|张三的店:餐厅|我发现了张三的店|1|NONE)
("relationship"|抖音:内容平台|张三的店:餐厅|张三的店在抖音上被展示|1|NONE)
```

---

### 2. `config/prompts/check_extraction.txt`

#### 主要修改

**添加核心策略说明**:

```markdown
## 核心策略：三阶段关系提取

**Phase 1: 原子关系** - 单一、直接的动作，refer=NONE
**Phase 3: 复杂关系** - 多方参与的事件，使用 refer 字段
**关键**: 两者共存，不是替换！
```

**检查要点重组**:

```markdown
### 1. 【关键】检查原子关系的完整性
**原则**: 每个单一动作都应该有对应的原子关系

**需要检查的原子关系类型**:
- ✅ 用户操作: 我 -> 实体:类（打开、看到、联系）
- ✅ 内容传递: 内容:类 -> 目标:类（分享、发送）
- ✅ 平台关系: 平台:类 -> 实体:类（展示、连接）
- ✅ 发现三角: 我->平台, 我->内容, 平台->内容

**检查**:
- 扫描文本，列出所有动作
- 检查每个动作是否有原子关系
- 原子关系的 refer 必须是 NONE
- 补充遗漏的原子关系

### 2. 【关键】检查复杂事件的 refer 关系
**识别复杂事件**: 涉及 >2 个实体的事件

**检查**:
- 复杂事件是否另起了关系（额外增加，不是替换）
- refer 字段是否正确包含其他参与实体
- refer 中的实体是否存在于实体列表中
- "我" 是否错误地出现在 refer 中（应该不出现）

**示例**:
"我通过微信把视频分享给小明" 应该有：
- 原子关系: 我->微信, 我->小明, 视频->小明, 微信->小明 (refer=NONE)
- 复杂关系: 微信->小明 (refer=[视频]), 视频->小明 (refer=[微信])
```

**优化步骤**:

```markdown
### Step A: 列出所有需要的原子关系
从文本中识别所有单一动作，确保每个动作都有原子关系。

### Step B: 识别复杂事件
找出涉及 >2 个实体的事件，为其另起关系（带 refer）。

### Step C: 检查并修复
- 原子关系的 refer 改为 NONE
- 复杂关系的 refer 填充其他参与实体
- 功能性关系改为 entity:class 格式
- 移除类主节点连接
```

**输出格式更新**:

```markdown
STEP 3 - Relationships:
# Phase 1: 原子关系（comment for clarity）
("relationship"|<source_node>|<target_node>|<relationship_description>|<relationship_count>|NONE)^
...
# Phase 3: 复杂事件关系（comment for clarity）
("relationship"|<source_node>|<target_node>|<relationship_description>|<relationship_count>|<refer_list>)^
...
```

---

### 3. `config/prompts/smart_merge.txt`

#### 主要修改

**新增规则 10**: 理解原子关系 vs 复杂关系

```markdown
10. **【理解】原子关系 vs 复杂关系**:
    - **原子关系**: 单一直接动作，refer=[]
      - 示例: "我 -> 微信:可启动应用" (打开微信)
      - 示例: "视频:内容 -> 小明:可联系人" (分享视频给小明)
    - **复杂关系**: 多方参与的事件，refer=[其他实体]
      - 示例: "微信:交流平台 -> 小明:可联系人", refer=["视频:内容"]
    - **共存原则**: 原子关系和复杂关系应该共存，不是互相替换
    - **合并注意**: 不要将原子关系和复杂关系错误地合并在一起
```

---

## 新增文档

### 1. `THREE_PHASE_RELATIONSHIP_EXTRACTION.md`

完整的三阶段策略说明文档，包含：

- **概述**: 三阶段策略的定义和原则
- **Phase 1**: 原子关系提取规则和示例
- **Phase 2**: 复杂事件识别标准
- **Phase 3**: 另起复杂关系的模式
- **完整示例**: 3个详细示例（分享视频、购物、发现）
- **关系唯一性**: 判断和合并规则
- **实现细节**: 各阶段的具体实现要求
- **优势**: 四大优势（完整性、查询能力、清晰度、灵活性）
- **注意事项**: 常见错误和正确做法
- **测试用例**: 3个测试场景

---

## 核心改进点

### 1. 完整性提升

**之前**:

- 只提取最终的复杂关系
- 基本动作可能被忽略
- 信息有丢失风险

**现在**:

- 提取所有原子关系
- 额外添加复杂关系
- 信息完整保留

### 2. 语义清晰度

**之前**:

```
# 可能只有这一条
("relationship"|我|小明:可联系人|我通过微信把视频分享给小明|1|微信:交流平台,关于AI绘图的视频)
```

**现在**:

```
# 原子关系（4条）
("relationship"|我|微信:可启动应用|我打开微信|1|NONE)
("relationship"|我|小明:可联系人|我联系了小明|1|NONE)
("relationship"|关于AI绘图的视频:内容|小明:可联系人|我把视频分享给小明|1|NONE)
("relationship"|微信:交流平台|小明:可联系人|我在微信上联系小明|1|NONE)

# 复杂关系（2条）
("relationship"|微信:交流平台|小明:可联系人|我通过微信把视频分享给小明|1|关于AI绘图的视频:内容)
("relationship"|关于AI绘图的视频:内容|小明:可联系人|我在微信上把视频分享给小明|1|微信:交流平台)
```

### 3. 查询能力增强

支持更多类型的查询：

| 查询类型 | 之前 | 现在 |
|---------|------|------|
| "我联系过小明几次？" | ❌ 难以统计 | ✅ 查询原子关系count |
| "我通过微信做了什么？" | ✅ 可以查询 | ✅ 更精准 |
| "视频被分享给谁了？" | ✅ 可以查询 | ✅ 有专门关系 |
| "我打开了哪些应用？" | ❌ 信息丢失 | ✅ 原子关系保留 |

### 4. Refer 字段规范

**明确规定**:

- ❌ "我" 不出现在 refer 中
- ✅ 必须使用 entity:class 格式
- ✅ 逗号分隔，无空格
- ✅ 原子关系 refer=NONE

---

## 示例对比

### 场景: "我在小红书上看到一个关于AI绘图的视频，然后用微信分享给了小明"

#### 优化前（可能的输出）

```
STEP 3 - Relationships:
("relationship"|我|小红书:内容平台|我在小红书上浏览|1|NONE)
("relationship"|我|小明:可联系人|我把视频分享给小明|1|微信:交流平台,关于AI绘图的视频:内容)
```

**问题**:

- ❌ 缺少"打开小红书"动作
- ❌ 缺少"发现视频"的三角关系
- ❌ 缺少"打开微信"动作
- ❌ 缺少基本的原子关系

#### 优化后（三阶段策略）

```
STEP 3 - Relationships:
# Phase 1: 原子关系
("relationship"|我|小红书:可启动应用|我打开小红书|1|NONE)
("relationship"|我|小红书:内容平台|我在小红书上浏览内容|1|NONE)
("relationship"|我|一个关于AI绘图的视频:内容|我看到了这个视频|1|NONE)
("relationship"|小红书:内容平台|一个关于AI绘图的视频:内容|小红书展示了这个视频|1|NONE)
("relationship"|我|微信:可启动应用|我打开微信|1|NONE)
("relationship"|我|小明:可联系人|我联系了小明|1|NONE)
("relationship"|一个关于AI绘图的视频:内容|小明:可联系人|我把视频分享给小明|1|NONE)
("relationship"|微信:交流平台|小明:可联系人|我在微信上联系小明|1|NONE)

# Phase 3: 复杂事件关系
("relationship"|微信:交流平台|小明:可联系人|我通过微信把视频分享给小明|1|一个关于AI绘图的视频:内容)
("relationship"|一个关于AI绘图的视频:内容|小明:可联系人|我在微信上把视频分享给小明|1|微信:交流平台)
```

**优势**:

- ✅ 完整保留所有基本动作（8条原子关系）
- ✅ 额外添加复杂事件关系（2条复杂关系）
- ✅ 信息完整，支持多种查询
- ✅ 层次清晰，易于理解

---

## 测试建议

### 测试用例 1: 简单分享

**输入**: "我通过微信把一个关于AI绘图的视频分享给小明"

**预期输出**:

- 原子关系: 4条（打开微信、联系小明、分享视频、微信联系）
- 复杂关系: 2条（带refer）
- 总计: 6条关系

**验证点**:

- [ ] 所有原子关系的 refer 都是 NONE
- [ ] 复杂关系的 refer 包含正确的参与实体
- [ ] "我" 不出现在 refer 中
- [ ] 使用 entity:class 格式

### 测试用例 2: 复杂购物

**输入**: "我在美团上用支付宝订了张三的店的咖啡"

**预期输出**:

- 原子关系: 6条（打开美团、浏览、订购店、使用支付宝、店展示、订购咖啡）
- 复杂关系: 2条（带refer，包含多个参与实体）
- 总计: 8条关系

**验证点**:

- [ ] 原子关系完整（每个动作都有）
- [ ] 复杂关系的 refer 包含多个实体
- [ ] refer 格式正确（逗号分隔，无空格）

### 测试用例 3: 发现三角

**输入**: "我在抖音上刷到张三的店"

**预期输出**:

- 原子关系: 4条（发现三角 + 打开抖音）
- 复杂关系: 0条（无多方复杂事件）
- 总计: 4条关系

**验证点**:

- [ ] 发现三角完整（我->抖音, 我->店, 抖音->店）
- [ ] 包含"打开抖音"原子关系
- [ ] 所有 refer 都是 NONE

---

## 迁移指南

### 对于使用者

1. **更新提示词文件**: 使用新的 `extract_graph.txt`, `check_extraction.txt`, `smart_merge.txt`

2. **理解新策略**: 阅读 `THREE_PHASE_RELATIONSHIP_EXTRACTION.md`

3. **测试新输出**: 使用测试用例验证新策略的效果

4. **调整预期**: 预期会有更多的关系（原子+复杂），这是正常的

### 对于开发者

1. **解析器兼容**: 确保解析器能正确处理注释（`# Phase 1`等）

2. **Refer 处理**:
   - `NONE` → 空数组 `[]`
   - 字符串 → 分割为数组

3. **关系数量**: 图谱中关系数量会增加，这是预期行为

4. **查询优化**: 利用原子/复杂关系的区别优化查询逻辑

---

## 常见问题

### Q1: 为什么关系数量变多了？

**A**: 这是正常的。三阶段策略会提取所有原子关系（基本动作），并额外添加复杂关系。这样做的目的是：

- 不丢失任何基本信息
- 完整表达复杂事件
- 支持更丰富的查询

### Q2: 原子关系和复杂关系有什么区别？

**A**:

- **原子关系**: 单一直接动作，refer=NONE，简单清晰
- **复杂关系**: 多方参与事件，refer=[其他实体]，语义完整

两者共存，提供不同层次的信息。

### Q3: "我"为什么不在 refer 中？

**A**: "我"作为用户本人，总是隐含存在于所有事件中。在 refer 中标注其他参与实体即可，无需重复标注"我"。

### Q4: 如何判断是否需要另起复杂关系？

**A**: 判断标准：

1. 事件涉及 >2 个实体
2. 需要表达"通过...做..."的完整语义
3. 原子关系无法完整表达事件

如果满足以上条件，就需要为复杂事件另起关系。

### Q5: 所有 >2 方的事件都需要复杂关系吗？

**A**: 不一定。例如"发现三角"（我在平台上发现内容），虽然有3方，但这是一个标准模式，原子关系（我->平台, 我->内容, 平台->内容）已经完整表达，无需额外的复杂关系。

---

## 总结

三阶段关系提取策略是一次重要的优化，带来了：

✅ **完整性**: 所有基本动作都被记录  
✅ **语义性**: 复杂事件被完整表达  
✅ **查询性**: 支持更丰富的图谱查询  
✅ **清晰度**: 原子/复杂关系职责分明  

**核心理念**: 原子关系和复杂关系**共存**，提供不同层次的语义表达，构建更完整、更强大的知识图谱！
