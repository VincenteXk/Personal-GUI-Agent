# 任务：智能合并增量更新

你是一个知识图谱合并专家，负责将新的增量更新智能合并到现有的知识图谱中。

## 当前System和Graph状态

### 当前System定义
```yaml
{current_system}
```

### 当前Graph摘要
- 实体数量: {entity_count}
- 关系数量: {relationship_count}
- 现有实体列表: {existing_entities}

### 现有实体详情（前20个）
```json
{existing_entities_detail}
```

## 待合并的增量更新

```json
{delta}
```

## 合并任务

请分析待合并的增量更新，执行以下任务：

### 1. 去重识别
识别增量中与现有图谱重复的实体和关系：
- 检查实体名称的同义词、缩写、不同表达方式
- 识别本质相同但描述不同的实体
- 检查重复的关系

### 2. 命名对齐
统一命名规范：
- 如果增量中的实体与现有实体是同一个，使用现有实体的名称
- 如果是新实体但命名不规范，优化命名
- 确保命名简洁、准确、一致

### 3. 冲突解决
处理属性值冲突：
- 如果同一实体的同一属性有不同值，选择更准确的值
- 如果无法判断，保留两个值并添加说明
- 合并互补的描述信息

### 4. 描述优化
优化实体和关系的描述：
- 合并重复信息
- 保留关键细节
- 使描述更加精准和完整

### 5. 操作决策
为每个增量项决定最终操作：
- "add": 全新的实体/关系，直接添加
- "merge": 与现有项合并，需要指定merge_target（目标实体名）
- "update": 更新现有项的属性/描述
- "skip": 完全重复，跳过

## 输出格式

请严格按照以下JSON格式输出（不要添加任何markdown标记）：

```json
{{
  "optimized_classes": [
    {{
      "name": "类名",
      "description": "优化后的描述",
      "properties": [
        {{
          "name": "属性名",
          "description": "属性描述",
          "required": false,
          "value_required": false,
          "operation": "add"
        }}
      ],
      "operation": "add"
    }}
  ],
  "optimized_entities": [
    {{
      "name": "优化后的实体名",
      "original_name": "原始实体名（如果修改了）",
      "description": "优化后的描述",
      "classes": ["类名1", "类名2"],
      "properties": {{
        "类名": {{
          "属性名": "属性值"
        }}
      }},
      "operation": "add",
      "merge_target": null,
      "reason": "操作原因说明"
    }}
  ],
  "optimized_relationships": [
    {{
      "source": "源实体名",
      "target": "目标实体名",
      "description": "优化后的关系描述",
      "count": 1,
      "refer": ["参与实体1", "参与实体2"],
      "operation": "add",
      "merge_target": null,
      "reason": "操作原因说明"
    }}
  ],
  "merge_summary": {{
    "duplicates_found": 2,
    "conflicts_resolved": 1,
    "names_aligned": 3,
    "descriptions_optimized": 5,
    "notes": "合并过程的总体说明"
  }}
}}
```

## 重要规则

1. **去重优先**: 宁可保守合并，也不要创建重复实体
2. **保留现有命名**: 如果实体已存在，使用现有名称
3. **信息不丢失**: 合并时不要丢失有价值的信息
4. **操作明确**: 每个项必须有明确的operation和reason
5. **JSON格式**: 输出必须是有效的JSON，不要添加任何其他内容

## 【严重警告】实体节点 vs 类节点：永远不要混淆！

**这是最关键的规则，违反此规则会导致严重的数据损坏！**

### 核心概念

在知识图谱系统中，有两种完全不同的节点类型：

1. **实体节点（Entity Node）**
   - 格式：`实体名`（不含冒号）
   - 示例：`张三的店`、`小红书`、`我`
   - 表示：一个具体的实体对象
   
2. **类节点（Class Node / Entity:Class Node）**
   - 格式：`实体名:类名`（含冒号）
   - 示例：`张三的店:商家`、`小红书:购物平台`、`我:用户`
   - 表示：该实体作为某个类的一个实例，是实体的特定方面

### 【关键】实体节点和类节点必须共存

**正确的结构**：
```json
// 实体节点
{{"name": "张三的店", "classes": ["商家", "现实地点"]}}

// 对应的类节点（自动生成）
// - 张三的店:商家
// - 张三的店:现实地点

// 关系可以指向实体节点或类节点
{{"source": "我", "target": "张三的店"}}  // 整体关系
{{"source": "我", "target": "张三的店:商家"}}  // 功能性关系
```

### 【严重错误】绝对不能做的事

❌ **错误 1：将类节点视为实体节点**
```json
// 错误：将"张三的店:商家"当作实体名
{{"name": "张三的店:商家", "classes": ["商家"]}}  // 大错特错！

// 正确：这是一个类节点引用，不是实体定义
// 实体定义是：{{"name": "张三的店", "classes": ["商家"]}}
```

❌ **错误 2：将类节点合并到实体节点**
```json
// 增量数据
{{"source": "我", "target": "张三的店:商家"}}

// 现有实体
{{"name": "张三的店"}}

// ❌ 错误操作：认为"张三的店:商家"应该合并到"张三的店"实体
// ✅ 正确操作：保持原样！"张三的店:商家"是类节点引用，不需要合并
```

❌ **错误 3：删除类节点引用的冒号部分**
```json
// 增量关系
{{"source": "我", "target": "张三的店:商家"}}

// ❌ 错误：将target修改为"张三的店"（删除了":商家"部分）
// ✅ 正确：保持"张三的店:商家"不变
```

### 【正确做法】识别和处理类节点引用

#### 识别方法

检查字符串中是否包含冒号 `:`:
- **包含冒号** → 这是类节点引用（`实体名:类名`）
- **不包含冒号** → 这是实体节点引用（`实体名`）

#### 处理规则

**规则 A：在关系的 source、target、refer 中**
```json
// 如果遇到"张三的店:商家"
1. 识别：这是类节点引用
2. 检查：实体"张三的店"是否存在
3. 检查：实体"张三的店"是否有"商家"类
4. 处理：
   a) 如果实体存在且有该类 → 保持"张三的店:商家"不变
   b) 如果实体存在但没有该类 → 可能需要添加该类到实体
   c) 如果实体不存在 → 需要创建实体并添加该类
5. 输出：保持关系中的"张三的店:商家"格式不变
```

**规则 B：绝对不要做的事**
```
❌ 不要将"张三的店:商家"作为实体名添加到 optimized_entities 中
❌ 不要将"张三的店:商家"合并到"张三的店"实体
❌ 不要将关系中的"张三的店:商家"修改为"张三的店"
❌ 不要创建名为"张三的店:商家"的实体（含冒号的不是实体名！）
```

### 【示例】正确的合并处理

#### 场景 1：增量包含类节点引用

**增量数据**：
```json
{{
  "entities": [
    {{"name": "张三的店", "classes": ["商家"]}}
  ],
  "relationships": [
    {{"source": "我", "target": "张三的店:商家", "description": "我在张三的店购物"}}
  ]
}}
```

**现有数据**：
```json
{{
  "entities": [
    {{"name": "张三的店", "classes": ["餐厅"]}}
  ]
}}
```

**正确的输出**：
```json
{{
  "optimized_entities": [
    {{
      "name": "张三的店",
      "classes": ["餐厅", "商家"],
      "operation": "update",
      "reason": "增量中新增了'商家'类，与现有'餐厅'类合并"
    }}
  ],
  "optimized_relationships": [
    {{
      "source": "我",
      "target": "张三的店:商家",
      "description": "我在张三的店购物",
      "operation": "add",
      "reason": "新增关系，target保持类节点格式"
    }}
  ]
}}
```

**注意**：
- ✅ 关系中的`"张三的店:商家"`保持不变（包含冒号）
- ✅ 实体定义中的`"name": "张三的店"`不含冒号
- ✅ 实体的classes数组中添加了"商家"

#### 场景 2：避免错误合并

**增量关系**：
```json
{{"source": "美团外卖:购物平台", "target": "张三的店的招牌套餐:商品"}}
```

**错误处理** ❌：
```json
// 将类节点引用错误地理解为需要创建的实体
{{
  "optimized_entities": [
    {{"name": "美团外卖:购物平台", "operation": "add"}}  // 大错！
  ]
}}
```

**正确处理** ✅：
```json
// 检查实体"美团外卖"是否存在，检查是否有"购物平台"类
{{
  "optimized_entities": [
    // 如果需要，创建或更新实体（不含冒号）
    {{"name": "美团外卖", "classes": ["购物平台"], "operation": "..."}}
  ],
  "optimized_relationships": [
    {{  
      "source": "美团外卖:购物平台",  // 保持冒号格式
      "target": "张三的店的招牌套餐:商品",  // 保持冒号格式
      "operation": "add"
    }}
  ]
}}
```

### 【检查清单】合并前必须确认

在输出 optimized_entities 之前，检查每个实体名称：

1. ✓ 是否包含冒号 `:`？
   - 如果是 → **这不是实体名！这是类节点引用！不要添加到 optimized_entities！**
   - 如果否 → 可以继续处理
   
2. ✓ 在 optimized_relationships 中：
   - source、target、refer 中的值可以包含冒号（类节点引用）
   - 这些值应该保持原样，不要删除冒号部分
   
3. ✓ 在 optimized_entities 中：
   - name 字段**绝对不能**包含冒号
   - 如果看到冒号，说明你犯了严重错误

### 【记忆口诀】

```
实体名称：不含冒号
类节点引用：含冒号
关系中可用：类节点引用
实体定义中：只用实体名

"张三的店" = 实体（可以在 optimized_entities 中）
"张三的店:商家" = 类节点引用（不能在 optimized_entities 中！）
```

## 【关键】实体重定向规则

**背景**: Delta数据可能基于较旧的system版本生成，而当前system已经更新，导致实体类型不匹配。

**问题场景示例**:
- 任务1: 提取"张三的店:餐厅" → 已合并到当前graph
- 任务2: 基于旧system（没有"张三的店"）提取"张三的店:地点"，并包含关系 "好评:内容 -> 张三的店:地点"
- 合并任务2时，当前graph已有"张三的店:餐厅"
- **正确做法**: 将任务2中的"张三的店:地点"重定向为"张三的店:餐厅"

**重定向规则**:

### 5.1 检测需要重定向的实体
- 如果增量中的实体名称与现有实体名称相同，但类不同（如 "张三的店:地点" vs "张三的店:餐厅"）
- 这表明delta基于旧版本生成，需要重定向到现有实体的类

### 5.2 实体重定向优先级
1. **优先使用现有实体的类**: 如果现有graph中已有该实体且有类，使用现有的类
2. **类合并**: 如果两个类都有价值，可以将delta的类作为额外的类添加到实体
3. **选择更具体的类**: 如果需要选择，选择更具体、更准确的类（如"餐厅"比"地点"更具体）

### 5.3 关系重定向

**关键理解**：
- 在关系中，`"张三的店:地点"` 和 `"张三的店:餐厅"` 都是**类节点引用**（含冒号）
- 它们引用的是同一个实体 `"张三的店"` 的不同类
- 重定向是指：将引用改为指向更准确的类

**重定向规则**：
1. **识别类节点引用**：检查是否包含冒号
2. **提取实体名和类名**：`"张三的店:地点"` → 实体=`"张三的店"`，类=`"地点"`
3. **检查现有实体的类**：查看实体 `"张三的店"` 有哪些类
4. **选择目标类**：
   - 如果现有实体有更准确的类（如`"餐厅"`），使用该类
   - 否则，保持增量中的类或添加新类
5. **更新关系引用**：将类节点引用更新为正确的格式

**示例**：
- 增量关系: `"好评:内容"` -> `"张三的店:地点"`（类节点引用）
- 现有实体: `{{"name": "张三的店", "classes": ["餐厅"]}}`
- 分析：`"张三的店:地点"` 引用的是实体 `"张三的店"` 的 `"地点"` 类
- 现有实体有更准确的类 `"餐厅"`
- 重定向后: `"好评:内容"` -> `"张三的店:餐厅"`（更准确的类节点引用）

**注意**：
- ✅ 重定向是改变**类节点引用**中的类部分
- ❌ 不是将**类节点引用**改为**实体节点**（不要删除冒号！）
- ❌ 不是创建名为 `"张三的店:地点"` 的实体（含冒号的不是实体名！）

### 5.4 重定向处理步骤
1. **识别重复实体**: 扫描增量中的所有实体，检查是否与现有实体同名但类不同
2. **决定目标类**: 根据现有实体的类和增量实体的类，决定最终使用哪个类
3. **更新实体**: 如果需要，将增量实体标记为"merge"操作，merge_target为现有实体名:现有类名
4. **更新所有关系**: 遍历所有关系，将引用旧实体:类的地方替换为新实体:类
5. **记录原因**: 在reason字段中说明进行了重定向以及原因

### 5.5 重定向示例

**场景**: 
- 现有实体: `{{"name": "张三的店", "classes": ["餐厅"]}}`
- 增量实体: `{{"name": "张三的店", "classes": ["地点"]}}`
- 增量关系: `{{"source": "好评:内容", "target": "张三的店:地点"}}`

**分析**：
1. 增量中的实体定义：`"张三的店"` 有类 `["地点"]`
2. 现有实体定义：`"张三的店"` 有类 `["餐厅"]`
3. 增量中的关系：引用类节点 `"张三的店:地点"`（含冒号，这是类节点引用！）
4. 决策：`"餐厅"` 比 `"地点"` 更具体，使用现有的类
5. 重定向：将关系中的类节点引用从 `"张三的店:地点"` 改为 `"张三的店:餐厅"`

**输出**:
```json
{{
  "optimized_entities": [
    {{
      "name": "张三的店",
      "classes": ["餐厅"],
      "operation": "skip",
      "reason": "实体已存在，类型为'餐厅'比增量中的'地点'更具体，保持现有类型"
    }}
  ],
  "optimized_relationships": [
    {{
      "source": "好评:内容",
      "target": "张三的店:餐厅",
      "operation": "add",
      "reason": "重定向类节点引用：原为'张三的店:地点'，现有实体的类为'餐厅'更准确，重定向为'张三的店:餐厅'"
    }}
  ]
}}
```

**关键要点**：
- ✅ 实体定义的 `name` 字段：`"张三的店"`（不含冒号）
- ✅ 关系中的 `target`：`"张三的店:餐厅"`（含冒号，类节点引用）
- ✅ 重定向只改变类节点引用的类部分（从 `:地点` 到 `:餐厅`）
- ❌ 绝不创建名为 `"张三的店:地点"` 或 `"张三的店:餐厅"` 的实体（含冒号的是引用，不是实体名！）

## 【重要】关系验证规则

6. **避免类主节点连接**: 
   - 检查所有关系，确保没有直接连接到类主节点（泛型类）
   - 类主节点示例：单独的"购物平台"、"社交平台"、"应用"等（没有具体实体名称）
   - ❌ 错误：{{"source": "我", "target": "购物平台"}} - "购物平台"是类主节点
   - ✅ 正确：{{"source": "我", "target": "小红书:购物平台"}} - 连接到具体实体的类节点
   - 如果发现这样的关系，应该：
     a. 优先找到或创建具体的实体，将关系连接到该实体或其类节点
     b. 如果无法确定具体实体，标记为"skip"并在reason中说明

7. **动作事件为关系，非实体**:
   - 检查是否有动作或事件被作为实体
   - 动作性事件（如"购买"、"浏览"、"联系"）应该是关系的描述，不应该是实体
   - 只有重大名词化事件（如"春节"、"产品发布会"）才应作为实体
   - 如果发现动作性事件作为实体，应标记为"skip"或转换为关系

8. **【强制】优先使用实体类节点（entity:class）而非纯实体节点**:
   - 检查所有关系的source和target
   - 如果关系涉及实体的特定功能，必须使用 "实体名:类名" 格式
   - ✅ 正确：{{"source": "我", "target": "高德地图:地图应用"}} - 使用地图功能
   - ❌ 错误：{{"source": "我", "target": "高德地图"}} - 应该明确标识功能
   - 只有整体性关系（如"我喜欢某实体"）才使用纯实体节点
   - 处理步骤：
     a. 分析关系描述，判断是否涉及特定功能
     b. 如果涉及特定功能，检查实体是否有对应的类
     c. 将关系修改为使用 "实体名:类名" 格式
     d. 在reason中说明优化原因

9. **【关键】Refer字段决定关系唯一性**:
   - **关系唯一性判断**：source + target + description + **refer** 都相同才是同一关系
   - **合并规则**：
     - ✅ 相同关系（可合并，累加count）：
       - "我 -> 某应用:可启动应用", description="打开应用", refer=[], count=1
       - "我 -> 某应用:可启动应用", description="打开应用", refer=[], count=1
       - → 合并为 count=2
     - ❌ 不同关系（不可合并）：
       - "我 -> 小明:可联系人", description="联系小明", refer=["问作业"]
       - "我 -> 小明:可联系人", description="联系小明", refer=["微信:交流平台","分享视频"]
       - → 保持为两条独立关系，因为 refer 不同（目的不同）
   - **Refer字段处理**：
     - 输出时必须包含 "refer" 字段
     - 如果没有其他参与实体，使用空数组 []
     - Refer中的实体必须在现有图谱或增量中存在
     - 合并时比较 refer 数组内容（顺序无关，但内容必须完全一致）

10. **【理解】原子关系 vs 复杂关系**:
    - **原子关系**: 单一直接动作，refer=[]
      - 示例: "我 -> 微信:可启动应用" (打开微信)
      - 示例: "视频:内容 -> 小明:可联系人" (分享视频给小明)
    - **复杂关系**: 多方参与的事件，refer=[其他实体]
      - 示例: "微信:交流平台 -> 小明:可联系人", refer=["视频:内容"] (通过微信把视频分享给小明)
    - **共存原则**: 原子关系和复杂关系应该共存，不是互相替换
    - **合并注意**: 不要将原子关系和复杂关系错误地合并在一起

请开始分析并输出优化后的增量更新。
