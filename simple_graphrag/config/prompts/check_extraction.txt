# 任务：检查和优化关系提取结果

你是一个知识图谱质量检查专家。你的任务是检查第一次提取的结果，找出问题并输出优化后的完整结果。

## 原始文本
{input_text}

## 第一次提取结果
{extraction_result}

## 核心策略：三阶段关系提取

**Phase 1: 原子关系** - 单一、直接的动作，refer=NONE
**Phase 3: 复杂关系** - 多方参与的事件，使用 refer 字段
**关键**: 两者共存，不是替换！

## 检查要点

### 0. 【最高优先级】关系提取的详尽性检查

**核心原则**: 
- ✅ **提取出的关系必须尽可能详尽，不要漏掉任何一个二元关系**
- ✅ **不要遗漏含第三方参与的二元关系**（即使用 refer 字段的关系）
- ✅ **每个文本中提到的动作、连接、发现、传递都应该被提取为关系**
- ✅ **宁可多提取也不要遗漏**，检查时重点关注是否有被遗漏的关系
- ❌ 发现遗漏的关系时必须补充，不要因为"看起来不重要"就跳过

**详尽性检查步骤**:
1. 逐句阅读原始文本，标记所有动作词（打开、看到、分享、购买、发现等）
2. 对每个动作词，检查是否有对应的关系
3. 检查是否有隐含的关系没有被提取（如"发现三角"的完整性）
4. 检查多方参与的事件是否既提取了原子关系又提取了复杂关系

### 1. 【关键】检查原子关系的完整性

**原则**: 每个单一动作都应该有对应的原子关系

**需要检查的原子关系类型**:
- ✅ 用户操作: 我 -> 实体:类（打开、看到、联系）
- ✅ 内容传递: 内容:类 -> 目标:类（分享、发送）
- ✅ 平台关系: 平台:类 -> 实体:类（展示、连接）
- ✅ 发现三角: 我->平台, 我->内容, 平台->内容

**检查**:
- 扫描文本，列出所有动作
- 检查每个动作是否有原子关系
- 原子关系的 refer 必须是 NONE
- 补充遗漏的原子关系

### 2. 【关键】检查复杂事件的 refer 关系

**识别复杂事件**: 涉及 >2 个实体的事件

**检查**:
- 复杂事件是否另起了关系（额外增加，不是替换）
- refer 字段是否正确包含其他参与实体
- refer 中的实体是否存在于实体列表中
- "我" 是否错误地出现在 refer 中（应该不出现）

**示例**:
- "我通过微信把视频分享给小明" 应该有：
  - 原子关系: 我->微信, 我->小明, 视频->小明, 微信->小明 (refer=NONE)
  - 复杂关系: 微信->小明 (refer=[视频]), 视频->小明 (refer=[微信])

### 3. 【强制】优先使用实体类节点（entity:class）

**规则**:
- 功能性关系 → entity:class (如"我->高德地图:地图应用")
- 整体性态度 → entity (如"我->高德地图"表示"我喜欢它")

**检查**:
- 扫描所有关系，判断是功能性还是态度性
- 功能性关系改为 entity:class 格式
- 确保类在该实体的类列表中

### 4. 避免泛指实体和类主节点连接

**泛指实体**:
- ✅ 具体名称: "《三体》", "关于AI的视频", "张三的店"
- ❌ 泛指: "书", "视频", "店"

**类主节点连接**:
- ✅ 连接具体实体: "我->小红书:购物平台"
- ❌ 连接类主节点: "我->购物平台"

### 5. 动作vs对象

- 动作(动词) → 关系描述: "购买"、"分享"、"打开"
- 对象(名词) → 实体: "视频"、"商品"、"应用"

### 6. 检查类节点的正确性

**可用类列表**:
{entity_types}

**检查**:
- 使用的类是否在可用类列表中
- 实体是否确实属于该类
- 实体:类 组合是否在 STEP 2 中定义

## 优化步骤

### Step A: 列出所有需要的原子关系
从文本中识别所有单一动作，确保每个动作都有原子关系。

### Step B: 识别复杂事件
找出涉及 >2 个实体的事件，为其另起关系（带 refer）。

### Step C: 检查并修复
- 原子关系的 refer 改为 NONE
- 复杂关系的 refer 填充其他参与实体
- 功能性关系改为 entity:class 格式
- 移除类主节点连接

## 输出格式

请输出优化后的完整结果，使用与第一次提取相同的格式：

```
STEP 1 - Entities:
("entity"|<entity_name>|<entity_description>)^
...

SECTION_DELIMITER

STEP 2 - Classes and Properties:
("class_property"|<entity_name>|<class_name>|<property_name>|<property_value>)^
...

SECTION_DELIMITER

STEP 3 - Relationships:
# Phase 1: 原子关系（comment for clarity）
("relationship"|<source_node>|<target_node>|<relationship_description>|<relationship_count>|NONE)^
...
# Phase 3: 复杂事件关系（comment for clarity）
("relationship"|<source_node>|<target_node>|<relationship_description>|<relationship_count>|<refer_list>)^
...

DONE
```

## 输出要求

1. **完整性**: 输出所有4个STEP（包括 STEP 0，即使是 NO_NEW_PROPERTIES）
2. **格式**: 使用相同分隔符 `|` `^` `SECTION_DELIMITER`
3. **关系格式**: 6个字段 `("relationship"|source|target|description|count|refer)`
4. **Refer格式**: 
   - 原子关系: `NONE`
   - 复杂关系: `entity1:class1,entity2:class2` (逗号分隔，无空格)
5. **注释**: 可以添加 `# Phase 1` 等注释以提高可读性
6. **完整输出**: 包含所有优化后的实体、类、关系

**关键**: 确保原子关系和复杂关系都存在，不要用复杂关系替换原子关系！

开始检查和优化：
